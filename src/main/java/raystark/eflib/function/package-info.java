/**
 * ラムダ式やメソッド参照のターゲットとなる関数型インターフェースを提供します。
 *
 * <p>このパッケージ下のインターフェースは全て関数型インターフェースです。以下では各インターフェースを関数と呼びます。
 * 関数の名前は実際に利用した時の可読性を確保するために元となる関数名の頭文字になっています。
 * 関数名と元となる関数名の対応は以下の5種類です。
 * <ul>
 *     <li>F: Function 型Tから型Rへの関数です。複数の引数を取る場合があり、関数名には引数の個数を表す数が続きます。</li>
 *     <li>P: Predicate 型Tの述語です。複数の引数を取る場合があり、関数名には引数の個数を表す数が続きます。</li>
 *     <li>C: Consumer 型Tの引数を受け取る手続きです。複数の引数を取る場合があり、関数名には引数の個数を表す数が続きます。</li>
 *     <li>S: Supplier 型Tのインスタンスの供給元です。</li>
 *     <li>A: Action 引数を受け取らない手続きです。</li>
 * </ul>
 *
 * <p>2つ以上の引数を取る関数は部分適用を行うapplyメソッド、および引数の順番を交換するswapメソッドを持ちます。
 * applyメソッドでは引数の個数だけ部分適用を行い、残りの引数を待機する関数を返します。
 * swapメソッドはswap2, swap3のようにメソッド名に数字続きます。swapメソッドでは第一引数とswapの後に続く数字に対応した引数を交換します。
 * 例えばswap2メソッドでは第一引数と第二引数を、swap3メソッドでは第一引数と第三引数を交換します。
 *
 * <p>Aを除くすべての関数は自身の型を他の型に変換するasメソッドを持ちます。メソッド名asには変換後の型が続きます。
 * 引数には変換に必要になる値や関数が要求されます。詳細はそれぞれの関数のドキュメントを参照してください。
 *
 * <p>全ての関数はofメソッドを持ち、明示的に型を指定して引数にラムダやメソッド参照を渡すことで指定した型の関数のインスタンスを作成することができます。
 * ラムダやメソッド参照からは関数の持つメソッドを直接呼び出すことが出来ませんが、
 * ofメソッドにより型を推論することでそれらのメソッドを呼び出すことができるようになります。
 * これにより、合成関数を1行で書くことが出来るようになります。以下は例です。
 *
 * <pre>{@code
 * F1.of(String::length).then1(num -> num*2).asC1(System.out::println).accept("10");
 * F1.of((String s) -> s.length()).then1(num -> num*2).asC1(System.out::println).accept("10");
 * }</pre>
 *
 * <p>参照するメソッドがオーバーロードされている場合はofメソッドの型を推論することが出来ません。この場合は
 * ラムダの引数やジェネリックメソッド呼び出しで明示的に型を指定して、どのメソッドを参照するか明確にしてください。
 *
 * <p>標準APIの関数、または類似の関数を受け取るメソッドに対して本パッケージ下の関数を渡す場合、メソッド参照を用いたイディオムが使えます。
 * 以下にStringからIntegerへの一変数関数F1の例を示します。
 *
 * <pre>{@code
 *  F1<String, Integer> f = Integer::parseInt;
 *  Stream.<String>of("1", "2", "3")
 *      .map(f::apply) // メソッド参照による型の変換
 *      .forEach(System.out::println);
 * }</pre>
 *
 * <p>参照するメソッドは関数毎に異なります。詳細は各関数のドキュメントを参照してください。
 *
 * <p>ドキュメントやアノテーションで特に言及されない限り、各関数のメソッドはnull値を受け取ったり、null値を返したりします。
 * また副作用を生む場合があります。しかし、明瞭なプログラムを書くためにC: ConsumerとA: Actionを除く全ての関数は副作用を持たず、
 * null値を扱わないようにすることが推奨されます。
 */
package raystark.eflib.function;