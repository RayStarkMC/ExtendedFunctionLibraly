/**
 * ラムダ式やメソッド参照のターゲットとなる関数型インターフェースを提供します。
 *
 * <p>このパッケージ下のインターフェースは全て関数型インターフェースです。
 * 各インターフェースの名前は実際に利用した時の可読性を確保するために元となる関数名の頭文字になっています。
 * 各インターフェースの頭文字と関数名の対応は以下の5種類です。
 * <ul>
 *     <li>F: Function 型Tから型Rへの関数です。複数の引数を取る場合があり、インターフェース名には引数の個数を表す数が付きます。</li>
 *     <li>P: Predicate 型Tの述語です。複数の引数を取る場合があり、インターフェース名には引数の個数を表す数が付きます。</li>
 *     <li>C: Consumer 型Tの引数を受け取る手続きです。複数の引数を取る場合があり、インターフェース名には引数の個数を表す数が付きます。</li>
 *     <li>S: Supplier 型Tのインスタンスの供給元です。</li>
 *     <li>A: Action 引数を受け取らない手続きです。</li>
 * </ul>
 *
 * <p>2つ以上の引数を取る型は部分適用を行うapplyメソッド、および引数の順番を交換するswapメソッドを持ちます。
 * applyメソッドでは引数の個数だけ部分適用を行い、残りの引数を待機する関数を返します。
 * swapメソッドはswap2, swap3のようにメソッド名に数字続きます。swapメソッドでは第一引数とswapの後に続く数字に対応した引数を交換します。
 * 例えばswap2メソッドでは第一引数と第二引数を、swap3メソッドでは第一引数と第三引数を交換します。
 *
 * <p>Aを除くすべての型は自信の型を他の型に変換するasメソッドを持ちます。メソッド名asには変換後の型が続きます。
 * 引数には変換に必要になる値や関数が要求されます。詳細はそれぞれの型のメソッドを参照してください。
 *
 * <p>全てのインターフェースはofメソッドを持ち、明示的に型を指定して引数にラムダやメソッド参照を渡すことで指定した型を持つインターフェースのインスタンスを作成することができます。
 * ラムダやメソッド参照からはインターフェースの持つメソッドを直接呼び出すことが出来ませんが、
 * ofメソッドにより型を推論することでそれらのメソッドを呼び出すことができるようになります。
 * これにより、合成関数を1行で書くことが出来るようになります。以下は例です。
 *
 * <pre>{@code
 *  F1.<String, Integer>of(Integer::parseInt).then1(num -> num*2).asC1(System.out::println).accept("10");
 *  F1.of((String s) -> Integer.parseInt(s)).then1(num -> num*2).asC1(System.out::println).accept("10");
 * }</pre>
 *
 * <p>ラムダの引数やジェネリックメソッド呼び出しで明示的に型を指定しているのに注意してください。
 * Javaには変数の利用先の型から変数の型を推論する機能が無いため、ofメソッド呼び出しで型を明示しない場合、それらはObject型と推論されます。
 *
 * <p>標準APIの関数型インターフェース型を受け取るメソッドに対して本パッケージ下の型のインスタンスを渡す場合、次のイディオムが使えます。
 *
 * <pre>{@code
 *  F1<String, Integer> f = Integer::parseInt;
 *  Stream.<String>of()
 *      .map(f::apply)
 *      .forEach(System.out::println);
 * }</pre>
 */
package raystark.eflib.function;