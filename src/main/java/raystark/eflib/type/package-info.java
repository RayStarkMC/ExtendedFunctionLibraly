/**
 * イレイジャ衝突回避用の型を提供します。
 *
 * <p>Javaではジェネリクスの実装にイレイジャ方式を採用しているため、
 * 同じイレイジャを持つ型の引数同士ではメソッドをオーバーロードすることが出来ません。
 * 例えば型変数T1、T2について次のコードはイレイジャが衝突するためコンパイルエラーになります。
 * <pre>{@code
 *  void someMethod(T1 t1);
 *  void someMethod(T2 t2);
 * }</pre>
 * しかし、本パッケージ下のインターフェースを用いると以下のようにT1、T2をラップしてメソッドを定義することが出来ます。
 * <pre>{@code
 *  void someMethod(Type1<T1> t1);
 *  void someMethod(Type2<T2> t2);
 * }</pre>
 * この場合はそれぞれのメソッドの引数は|Type1|, |Type2|(パッケージ名略)
 * とそれぞれ異なるイレイジャを持つようになるためオーバーロードが出来ます。
 *
 * <p>Type型は全て抽象メソッドunwrapを持つ関数型インターフェースなので、呼び出し側はsomeMethodを以下のように利用できます。
 * <pre>{@code
 *  T1 t1 = ...;
 *  T2 t2 = ...;
 *
 *  someMethod(() -> t1);
 *  someMethod(() -> t2);
 * }</pre>
 * この時Type1、Type2のどちらのラムダインスタンスを生成するかはt1、t2の型に依存し自動的に選択されるため、
 * 呼び出し側はsomeMethodの利用時にType1, Type2の存在を殆ど意識する必要がありません。
 *
 * <p>メソッドの定義側ではunwrapメソッドによりラップされた値を取り出すことができます。
 */
package raystark.eflib.type;